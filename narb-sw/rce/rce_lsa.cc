/*
 * Copyright (c) 2007
 * DRAGON Project.
 * University of Southern California/Information Sciences Institute.
 * All rights reserved.
 *
 * Created by Xi Yang 2004-2007
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
#include <zlib.h>
#include "rce_lsa.hh"
#include "rce_log.hh"
#include "rce_config.hh"
#include "terce_apiclient.hh"

void LSAHandler::Run()
{
    assert(rc);

    //Update into RDB
    switch(action)
    {
    case ACT_UPDATE:
        //Speical pre-handling for local physical links that have incomplete TE information
        //This is to avoid taking in incomplete TE links generated by instablity in OSPF adjacency initiation
        if (rc->Type() == RTYPE_LOC_PHY_LNK || rc->Type() == RTYPE_GLO_ABS_LNK)
        {
            if (((Link*)rc)->IsIncomplete())
            {
                RDB.BookmarkIncompleteLink((Link*)rc);
            }
            else 
            {
                Prefix prefix_incomplete = ((Link*)rc)->IncompleteIndex();
                RadixNode<Resource>* linknode_incomplete= RDB.LookupIncompleteLinkNode(rc->Type(), &prefix_incomplete);
                if (linknode_incomplete)
                {
                    RDB.RemoveIncompleteLinkNode(linknode_incomplete);
                }
            }
        }
        //regular update
        RDB.Update(rc);
        break;
    case ACT_DELETE:
        if (rc->Type() == RTYPE_LOC_PHY_LNK || rc->Type() == RTYPE_GLO_ABS_LNK)
        {
            Prefix prefix_incomplete = ((Link*)rc)->IncompleteIndex();
            RadixNode<Resource>* linknode_incomplete= RDB.LookupIncompleteLinkNode(rc->Type(), &prefix_incomplete);
            if (linknode_incomplete)
            {
                RDB.RemoveIncompleteLinkNode(linknode_incomplete);
            }
        }
        RDB.Delete(rc);
        delete rc;
        break;
    default:
        delete rc;
    }
        
    rc = NULL;
}

LSAHandler::~LSAHandler()
{
    if (lsa) 
        delete [](char*)lsa;
    if (rc)
        delete rc;
}

void LSAHandler::Load(api_msg* msg)
{
    //For now, we assume that each message contains only one LSA.
    int len = ntohs(msg->hdr.msglen);
    lsa = (lsa_header*) new char[len];
    memcpy(lsa, msg->body, len);
    domain_mask = msg->hdr.msgtag[0];
    action = (api_action)msg->hdr.action;
    api_msg_delete(msg);
}

#define ZBUFSIZE 1024
u_char zbuffer[ZBUFSIZE];

Resource* LSAHandler::Parse()
{
    if (lsa == NULL)
    	return NULL;

    assert (rc == NULL);

    u_int32_t lsa_id;
    u_char lsa_type;
    struct te_tlv_header *tlvh = NULL;
    struct te_tlv_header *sub_tlvh = NULL;
    u_int32_t read_len;

    if (lsa->type != OSPF_OPAQUE_AREA_LSA &&  lsa->type != OSPF_OPAQUE_LINK_LSA)
    {
        LOG_CERR<<"LSAHandler::Parse()::NOT_TE_LSA"<<endl;
        return NULL;
    }

    lsa_type = GET_OPAQUE_TYPE(ntohl(lsa->id.s_addr));
    lsa_id = GET_OPAQUE_ID(ntohl(lsa->id.s_addr));

    if ((lsa->type == OSPF_OPAQUE_AREA_LSA && lsa_type != OPAQUE_TYPE_TE_AREA_LSA) ||
         (lsa->type == OSPF_OPAQUE_LINK_LSA && (lsa_type != OPAQUE_TYPE_TE_LINKLOCAL_LSA ||
                                                                                        lsa_id != 0)))
    {
        LOG_CERR<<"LSAHandler::Parse()::NOT_TE_LSA"<<endl;
        return NULL;
    }

    tlvh = TLV_HDR_TOP(lsa);

    // check top-level tlv
    if (lsa->type == OSPF_OPAQUE_AREA_LSA && ntohs(tlvh->type) == TE_TLV_ROUTER_ADDR)
    {
    	 rc = new RouterId (domain_mask == DOMAIN_MASK_LOCAL? RTYPE_LOC_RTID : RTYPE_GLO_RTID, 
                    0, ((struct te_tlv_router_addr *)tlvh)->value.s_addr);
    }
    else if (lsa->type == OSPF_OPAQUE_AREA_LSA && ntohs(tlvh->type) == TE_TLV_LINK)
    {
        Link *link = new Link(domain_mask == DOMAIN_MASK_LOCAL ? RTYPE_LOC_PHY_LNK : RTYPE_GLO_ABS_LNK, 0, 0, 0);
        read_len = 0;
        link->advRtId = lsa->adv_router.s_addr;
        sub_tlvh = SUBTLV_HDR_TOP(tlvh);
        ISCD * swcap;
        IACD * adcap;
        Reservation * resv;
        int opaque_length = ntohs(lsa->length) - sizeof(struct lsa_header);

        while (read_len <  opaque_length - TLV_HDR_SIZE)
        {
              int a_index, i;
 
#ifdef HAVE_EXT_ATTR
              RcAttrDataType a_type;
              ResourceIndexingElement *pe;
              pe =  GET_ATTR(domain_mask == DOMAIN_MASK_LOCAL ? RTYPE_LOC_PHY_LNK : RTYPE_GLO_ABS_LNK, 
                                                  ntohs(sub_tlvh->type));
              a_index = ATTR_INDEX(domain_mask == DOMAIN_MASK_LOCAL ? RTYPE_LOC_PHY_LNK : RTYPE_GLO_ABS_LNK, 
                                                  ntohs(sub_tlvh->type));
#endif

        	switch (ntohs(sub_tlvh->type))
        	{
        		case TE_LINK_SUBTLV_LINK_TYPE:
        			link->linkType = ((struct te_link_subtlv_link_type *)sub_tlvh)->link_type.value;
        		       #ifdef HAVE_EXT_ATTR
                                link->SetAttribute(a_index, pe ? pe->dataType: 0, pe ? pe->dataLen : 0, &link->linkType);
                            #endif
        			break;
        		case TE_LINK_SUBTLV_LINK_ID:
        			link->id = ((struct te_link_subtlv_link_id *)sub_tlvh)->value.s_addr;
        		       #ifdef HAVE_EXT_ATTR
                              link->SetAttribute(a_index, pe ? pe->dataType: 0, pe ? pe->dataLen : 0, &link->id);
                            #endif
        			break;
        		case TE_LINK_SUBTLV_LCLIF_IPADDR:
        			link->lclIfAddr = ((struct te_link_subtlv_lclif_ipaddr *)sub_tlvh)->value.s_addr;
            		       #ifdef HAVE_EXT_ATTR
                               link->SetAttribute(a_index, pe ? pe->dataType: 0, pe ? pe->dataLen : 0, &link->lclIfAddr);
                            #endif
        			break;
        		case TE_LINK_SUBTLV_RMTIF_IPADDR:
        			link->rmtIfAddr = ((struct te_link_subtlv_rmtif_ipaddr *)sub_tlvh)->value.s_addr;
        		       #ifdef HAVE_EXT_ATTR
                                link->SetAttribute(a_index, pe ? pe->dataType: 0, pe ? pe->dataLen : 0, &link->rmtIfAddr);
                            #endif
        			break;
        		case TE_LINK_SUBTLV_TE_METRIC:
        			link->metric = ntohl(((struct te_link_subtlv_te_metric *)sub_tlvh)->value);
                            if (domain_mask == DOMAIN_MASK_GLOBAL)
                                link->metric += SystemConfig::metric_interdomain_nice_incremental;
        		       #ifdef HAVE_EXT_ATTR
                                link->SetAttribute(a_index, pe ? pe->dataType: 0, pe ? pe->dataLen : 0, &link->metric);
                            #endif
        			break;
        		case TE_LINK_SUBTLV_MAX_BW:
                            link->maxBandwidth = ((struct te_link_subtlv_max_bw *)sub_tlvh)->value;
                            ntohf_mbps(link->maxBandwidth);
        		       #ifdef HAVE_EXT_ATTR
                                link->SetAttribute(a_index, pe ? pe->dataType: 0, pe ? pe->dataLen : 0, &link->maxBandwidth);
                            #endif
        			break;
        		case TE_LINK_SUBTLV_MAX_RSV_BW:
        			link->maxReservableBandwidth = ((struct te_link_subtlv_max_rsv_bw *)sub_tlvh)->value;
                            ntohf_mbps(link->maxReservableBandwidth);
        		       #ifdef HAVE_EXT_ATTR
                                link->SetAttribute(a_index, pe ? pe->dataType: 0, pe ? pe->dataLen : 0, &link->maxReservableBandwidth);
                            #endif
        			break;
        		case TE_LINK_SUBTLV_UNRSV_BW:
                            memcpy(link->unreservedBandwidth, ((struct te_link_subtlv_unrsv_bw *)sub_tlvh)->value, sizeof(float)*8);
                            for (i = 0; i < 8; i++)
                                ntohf_mbps(link->unreservedBandwidth[i]);
        		       #ifdef HAVE_EXT_ATTR
                                link->SetAttribute(a_index, pe ? pe->dataType: 0, pe ? pe->dataLen : 0, link->unreservedBandwidth);
                            #endif
        			break;
        		case TE_LINK_SUBTLV_RSC_CLSCLR:
        			link->rcClass = ntohl(((struct te_link_subtlv_rsc_clsclr *)sub_tlvh)->value);
        		       #ifdef HAVE_EXT_ATTR
                                link->SetAttribute(a_index, pe ? pe->dataType: 0, pe ? pe->dataLen : 0, &link->rcClass);
                            #endif
        			break;
        		case TE_LINK_SUBTLV_LINK_LCRMT_ID:
        			link->lclId = ((struct te_link_subtlv_link_lcrmt_id *)sub_tlvh)->link_local_id;
        			link->rmtId = ((struct te_link_subtlv_link_lcrmt_id *)sub_tlvh)->link_remote_id;
        		       #ifdef HAVE_EXT_ATTR
                                link->SetAttribute(a_index, pe ? pe->dataType: 0, pe ? pe->dataLen : 0,  link->lclRmtId);
                            #endif
        			break;
        		case TE_LINK_SUBTLV_DOMAIN_ID:
        			link->domainId = (domain_mask & ntohl(((struct te_link_subtlv_domain_id *)sub_tlvh)->value));
                            if (domain_mask == DOMAIN_MASK_GLOBAL && link->domainId != 0)
                            {
                                //adding to RDB.routerToDomainDirectory
                                list<RouterId2DomainId*>::iterator iter;
                                RouterId2DomainId* r2d_conv;
                                bool found = false;
                                for (iter = RDB.routerToDomainDirectory.begin(); iter != RDB.routerToDomainDirectory.end(); iter++)
                                {
                                    r2d_conv = *iter;
                                    if (link->advRtId == r2d_conv->router_id)
                                    {
                                        found = true;
                                        break;
                                    }
                                }
                                if (!found)
                                {
                                    r2d_conv = new (struct RouterId2DomainId);
                                    r2d_conv->router_id = link->advRtId;
                                    r2d_conv->domain_id = link->domainId;
                                    RDB.routerToDomainDirectory.push_back(r2d_conv);
                                }
                                //reverting 'link->metric += SystemConfig::metric_interdomain_nice_incremental'
                                //The Metric TLV has been added with metric_interdomain_nice_incremental, now revert those from other domains.
                                if (ntohl(link->domainId) != SystemConfig::domainId && link->metric > SystemConfig::metric_interdomain_nice_incremental)
                                    link->metric -= SystemConfig::metric_interdomain_nice_incremental;
                            }  

        		       #ifdef HAVE_EXT_ATTR
                                link->SetAttribute(a_index, pe ? pe->dataType: 0, pe ? pe->dataLen : 0, &link->domainId);
                            #endif
        			break;
        		case TE_LINK_SUBTLV_LINK_IFSWCAP:
                            swcap = new ISCD;
                            //memcpy(swcap, (char*)sub_tlvh+TLV_HDR_SIZE, ISCD_MADATORY_SIZE); // only the madatory part
                            memcpy(swcap, (char*)sub_tlvh+TLV_HDR_SIZE, ntohs(sub_tlvh->length));
                            for (i = 0; i < 8; i++)
                                ntohf_mbps(swcap->max_lsp_bw[i]); 
                            if (ntohs(sub_tlvh->length) > ISCD_MADATORY_SIZE &&
                                (swcap->swtype == LINK_IFSWCAP_SUBTLV_SWCAP_L2SC 
                                || swcap->swtype == LINK_IFSWCAP_SUBTLV_SWCAP_LSC
                                || swcap->swtype == LINK_IFSWCAP_SUBTLV_SWCAP_FSC))
                            {
                                //memcpy((char*)swcap + ISCD_MADATORY_SIZE, (char*)sub_tlvh+TLV_HDR_SIZE+ISCD_MADATORY_SIZE, 4);
                                if (swcap->swtype == LINK_IFSWCAP_SUBTLV_SWCAP_L2SC && (ntohs(swcap->vlan_info.version) & IFSWCAP_SPECIFIC_VLAN_BASIC)) 
                                {
                                    memcpy((char*)swcap + ISCD_MADATORY_SIZE, (char*)sub_tlvh+TLV_HDR_SIZE + ISCD_MADATORY_SIZE, ntohs(swcap->vlan_info.length));
                                    if (ntohs(swcap->vlan_info.version) & IFSWCAP_SPECIFIC_VLAN_COMPRESS_Z)
                                    {
                                        u_int32_t bitmask_len = sizeof(link_ifswcap_specific_vlan) -4;
                                        uncompress(zbuffer, (uLongf*)&bitmask_len, swcap->vlan_info.bitmask, ntohs(swcap->vlan_info.length) - 4);
                                        assert (bitmask_len == sizeof(link_ifswcap_specific_vlan) - 4); //debug...
                                        memcpy(swcap->vlan_info.bitmask, zbuffer, bitmask_len);
                                        swcap->vlan_info.length = htons(bitmask_len + 4);
                                    }
                                }
                                if ( (swcap->swtype == LINK_IFSWCAP_SUBTLV_SWCAP_L2SC) && (ntohs(swcap->subnet_uni_info.version) & IFSWCAP_SPECIFIC_SUBNET_UNI)) 
                                {
                                    memcpy((char*)swcap + ISCD_MADATORY_SIZE, (char*)sub_tlvh+TLV_HDR_SIZE + ISCD_MADATORY_SIZE, ntohs(swcap->subnet_uni_info.length));
                                }
                            }                        
                            else
                                swcap->min_lsp_bw = 0; //ntohf_mbps(swcap->min_lsp_bw);  //min_lsp_bw (for TDM) will be handled in future
                            link->iscds.push_back(swcap);
        		       #ifdef HAVE_EXT_ATTR
                                assert (a_index > 0);
                                if (link->attrTable.size() < a_index +1)
                                {
                                    link->attrTable.resize(a_index+1);
                                }
                                link->attrTable[a_index].t = pe->dataType;
                                link->attrTable[a_index].l = pe->dataLen;
                                link->attrTable[a_index].p = &link->iscds;
                            #endif
        			break;
                    case TE_LINK_SUBTLV_LINK_IFADCAP:
                            adcap = (IACD*)new char[sizeof(IACD)];
                            memcpy(adcap, (char*)sub_tlvh+TLV_HDR_SIZE, sizeof(IACD));
                            for (i = 0; i < 8; i++)
                                ntohf_mbps(swcap->max_lsp_bw[i]); 
                            link->iacds.push_back(adcap);
        		       #ifdef HAVE_EXT_ATTR
                                assert (a_index > 0);
                                if (link->attrTable.size() < a_index +1)
                                {
                                    link->attrTable.resize(a_index+1);
                                }
                                link->attrTable[a_index].t = pe->dataType;
                                link->attrTable[a_index].l = pe->dataLen;
                                link->attrTable[a_index].p = &link->iacds;
                            #endif
                            break;
                    case TE_LINK_SUBTLV_RESV_SCHEDULE:
                            resv = (Reservation *)((char*)sub_tlvh+TLV_HDR_SIZE);
                            ntohf_mbps(resv->bandwidth);
                            for (i = 0; i < ntohs(sub_tlvh->length)/RESV_SIZE; i++)
                            {
                                Reservation * resv_allocated = link->resvTable.Allocate(resv->uptime, resv->duration);
                                if (resv_allocated)
                                {
                                    *resv_allocated = *(resv++);
                                }
                                else
                                {
                                    LOGF("Conflicted reservation: [%d, %d]: %f Mbps by LSP (%x/%x)\n", resv->uptime, 
                                        resv->uptime+resv->duration, resv->bandwidth, resv->domain_id, resv->lsp_id);
                                }
                            }
        		       #ifdef HAVE_EXT_ATTR
                                assert (a_index > 0);
                                if (link->attrTable.size() < a_index +1)
                                {
                                    link->attrTable.resize(a_index+1);
                                }
                                link->attrTable[a_index].t = pe->dataType;
                                link->attrTable[a_index].l = pe->dataLen;
                                link->attrTable[a_index].p = &link->resvTable.reserves;
                            #endif
                            break;
                    default:
        		       #ifdef HAVE_EXT_ATTR
                                if (pe == NULL)
                                      LOGF("The sub-tlv type %d is not supported.\n", ntohs(sub_tlvh->type));
                                else
                                {
                                    assert (a_index > 0);
                                    if (link->attrTable.size() < a_index +1)
                                    {
                                        link->attrTable.resize(a_index+1);
                                    }

                                    char * data = new char[ntohs(sub_tlvh->length)];
                                    memcpy(data, (char*)sub_tlvh+TLV_HDR_SIZE, ntohs(sub_tlvh->length));
                                    link->SetAttribute(a_index, pe ? pe->dataType: 0, pe ? pe->dataLen : 0, data);
                                }   
                            #else
                                LOGF("The sub-tlv type %d is not supported.\n", ntohs(sub_tlvh->type));
                            #endif
                            
        			break;
        	}
        	read_len += TLV_SIZE(sub_tlvh);
        	sub_tlvh = SUBTLV_HDR_NEXT(sub_tlvh);
        }

        // Check if mandatory sub-tlvs are included in this link tlv
        if (link->linkType == 0 || link->id == 0)
        {
            LOG_CERR<<"LSAHandler::Parse()::Madatory LINK-SUB_TLV(s) missing" <<endl;
            delete link;
        }
        else
        {
            rc = link;
        }
    }
    else if (lsa->type == OSPF_OPAQUE_LINK_LSA && ntohs(tlvh->type) == TE_TLV_LINK_LOCAL_ID)
    {
        LOG_CERR<<"RCE ignores OPAQUE LINK LOCAL ID LSA"<<endl;
    }
    else
    {
        LOG_CERR<<"LSAHandler::Parse()::Unrecognized TE-LSA due to incorrect TLV header info."<<endl;
    }

    if (rc)
        rc->domainMask = domain_mask;
    return rc;
}

/////////////////////////////////////////

void LSARetriever::Run()
{
    assert (api_writer);
    assert (api_reader);
    int ret;
    int action_ret = ACT_NOOP;
    if (query_options & LSA_QUERY_PHY)
    {
        if ((ret = RetrieveTopology(true)) != 0)
        {
            action_ret = ACT_ERROR;
            goto _out;
        }
    }
    if (query_options & LSA_QUERY_ABS)
    {
        if ((ret = RetrieveTopology(false)) != 0)
        {
            action_ret = ACT_ERROR;
            goto _out;
        }
    }

_out:
    api_msg * msg = api_msg_new(MSG_LSA, action_ret, &ret, ucid, seqnum, action_ret == ACT_NOOP ? 0 : 4, domain_mask);
    api_writer->PostMessage(msg);
}

bool LSARetriever::Parse(api_msg* msg)
{
    action = (api_action)msg->hdr.action;
    if (action != ACT_QUERY || ntohs(msg->hdr.msglen) !=0)
        return false;
    ucid = ntohl(msg->hdr.ucid);
    seqnum = ntohl(msg->hdr.msgseq);
    query_options = ntohl(msg->hdr.options);
    if (query_options = 0)
        return false;
    domain_mask = ntohl(msg->hdr.tag);
    api_msg_delete(msg);
    return true;
}

int LSARetriever::RetrieveTopology (bool physical)
{
    int ret = 0, retx;

    RadixTree<Resource>* tree;
    RadixNode<Resource> *node;

    // originate router-id LSA's
    tree = RDB.Tree(physical ? RTYPE_LOC_RTID : RTYPE_GLO_RTID);
    node = tree->Root();
    while (node)
    {
        RouterId* router_id = (RouterId*)node->Data();
        if (router_id != NULL)
        {
            if ((query_options & LSA_QUERY_ANY_DOMAIN) == 0 && domain_mask != 0 && (domain_mask & router_id->DomainId()) == domain_mask)
                continue;

            retx = this->RetrieveRouterId(router_id);
            if (ret == 0 && retx != 0)
                ret = retx;
        }

        node = tree->NextNode(node);
    }

    // originate  te-link LSA's
    tree = RDB.Tree(physical ? RTYPE_LOC_PHY_LNK : RTYPE_GLO_ABS_LNK);
    node = tree->Root();
    while (node)
    {
        Link* link = (Link*)node->Data();
        if (link != NULL)
        {
            if ((query_options & LSA_QUERY_ANY_DOMAIN) == 0 && domain_mask != 0 && (domain_mask & link->DomainId()) == domain_mask)
                continue;
            if (link->Iscds().size() == 0)
                continue;
            IfSwCapDesc *iscd = link->Iscds().front();
            if ((query_options&LSA_QUERY_FSC) && iscd->swtype == LINK_IFSWCAP_SUBTLV_SWCAP_FSC
              ||(query_options&LSA_QUERY_LSC) && iscd->swtype == LINK_IFSWCAP_SUBTLV_SWCAP_LSC
              ||(query_options&LSA_QUERY_TDM) && iscd->swtype == LINK_IFSWCAP_SUBTLV_SWCAP_TDM
              ||(query_options&LSA_QUERY_L2SC) && iscd->swtype == LINK_IFSWCAP_SUBTLV_SWCAP_L2SC
              ||(query_options&LSA_QUERY_PSC1) && iscd->swtype == LINK_IFSWCAP_SUBTLV_SWCAP_PSC1
              ||(query_options&LSA_QUERY_PSC2) && iscd->swtype == LINK_IFSWCAP_SUBTLV_SWCAP_PSC2
              ||(query_options&LSA_QUERY_PSC3) && iscd->swtype == LINK_IFSWCAP_SUBTLV_SWCAP_PSC3
              ||(query_options&LSA_QUERY_PSC4) && iscd->swtype == LINK_IFSWCAP_SUBTLV_SWCAP_PSC4)
            {
                retx = this->RetrieveTeLink(link);
                if (ret == 0 && retx != 0)
                    ret = retx;
            }
        }

        node = tree->NextNode(node);
    }

    return ret;
}


int LSARetriever::RetrieveLsa(in_addr adv_id, u_char lsa_type, u_char opaque_type, u_int32_t opaque_id, void * opaquedata, int opaquelen)
{  
    u_char buf[API_MAX_MSG_SIZE];
    struct lsa_header *lsah;
    u_int32_t tmp;

    // Make a new LSA from parameters 
    lsah = (lsa_header *) buf;
    lsah->ls_age = 0;
    lsah->options = 0;
    lsah->type = lsa_type;
  
    tmp = SET_OPAQUE_LSID (opaque_type, opaque_id);
    lsah->id.s_addr = htonl (tmp);
    lsah->adv_router = adv_id;
    lsah->ls_age = 0;
    lsah->ls_seqnum = 0;
    lsah->checksum = 0;
    lsah->length = htons (sizeof (lsa_header) + opaquelen);
  
    memcpy (((u_char *) lsah) + sizeof (lsa_header), opaquedata, opaquelen);

    u_int32_t ucid = ucid;
    api_msg * msg = api_msg_new(MSG_LSA, ACT_INSERT, lsah, ucid, get_rce_seqnum(), htons(lsah->length), domain_mask);

    if (!msg)
    {
        LOG("api_msg_new failed"<<endl);
        return -1;
    }

    if (api_writer->WriteMessage(msg) < 0)
    {
        LOG ("LSARetriever::RetrieveLsa / WriteMessage failed\n" << endl);
        return -1;
    }

    msg = api_reader->ReadMessage();
    if (!msg)
    {
        LOG ("LSARetriever::RetrieveLsa / ReadMessage failed\n" << endl);
        return -1;
    }

    int ret = 0;
    if (msg->hdr.action == ACT_ERROR) 
    {
        ret = ntohl(msg->hdr.tag);
    }
    api_msg_delete(msg);
    return ret;
}

int LSARetriever::RetrieveRouterId (RouterId* rtid)
{
    int ret = 0;

    void *opaquedata;
    int opaquelen;
    u_char lsa_type = 10;
    u_char opaque_type = 1;

    opaquedata = (void *)TerceApiTopoOriginator::BuildRouterIdOpaqueData(rtid); 
    opaquelen = ntohs(((struct te_tlv_header *)opaquedata)->length)
                  + sizeof (struct te_tlv_header);

    //using Router ID as the opaque ID, which TERCE should not care
	u_int32_t adv_rt_id = rtid->AdvRtId();
    ret = RetrieveLsa(*(in_addr*)&adv_rt_id, lsa_type, opaque_type, rtid->Id(), opaquedata, opaquelen);
    free(opaquedata);
    return ret;
}

int LSARetriever::RetrieveTeLink (Link* link)
{
    int ret = 0;
  
    u_char lsa_type = 10;
    u_char opaque_type = 1;
    
    void *opaquedata = TerceApiTopoOriginator::BuildTeLinkOpaqueData(link);
    int opaquelen = ntohs(((struct te_tlv_header *)opaquedata)->length)
                      + sizeof (struct te_tlv_header);

    //using Link Local IfAddr as the opaque ID, which TERCE should not care
	u_int32_t adv_rt_id = link->AdvRtId();
    ret = RetrieveLsa(*(in_addr*)&adv_rt_id, lsa_type, opaque_type, link->LclIfAddr(), opaquedata, opaquelen);
    free(opaquedata);
    return ret;
}

